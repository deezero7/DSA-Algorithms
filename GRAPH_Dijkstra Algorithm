// User Function Template
class Solution {
  public:
    vector<int> dijkstra(int V, vector<vector<int>> &edges, int src) {
        // Code here
        
        // make adj list 
        unordered_map<int, vector<pair<int, int>>> umap;
        for(auto& ele: edges){
            umap[ele[0]].push_back({ele[1], ele[2]});
            umap[ele[1]].push_back({ele[0], ele[2]});
        }
        
        // for bfs travers instead of queue use min_heap for least element at top
        priority_queue<pair<int,int> , vector<pair<int,int>>, greater<pair<int, int>>> pq;
        
        pq.push({0, src}); // first weight, node , so least weight at top
        // result for least weight 
        vector<int> result(V, INT_MAX);
        result[src] = 0;
        
        // bfs
        while(!pq.empty()){
            
            int weight = pq.top().first;
            int node = pq.top().second;
            pq.pop();
            
            for(auto& ele: umap[node]){
                int nde = ele.first;
                int wgt = ele.second;
                
                if(weight + wgt < result[nde]){
                    result[nde] = weight + wgt;
                    // push curr ele in pq
                    pq.push({weight+wgt, nde});
                }
            }
        }
        
        return result;
    }
};
